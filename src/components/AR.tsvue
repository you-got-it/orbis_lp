<template>
  <div ref="container" id="ar" class="ar">
    <canvas
      class="ar__canvas"
      ref="3d"
      width="10px"
      height="10px"
      @click="canvasClick"
      :style="isDesktop ? { background: '#f2f2f2' } : {}"
    ></canvas>
  </div>
</template>

<script lang="ts">
import { Component, Prop, Vue } from "vue-property-decorator";
import {
  Texture,
  AddOperation,
  EquirectangularReflectionMapping,
  BoxGeometry,
  BoxBufferGeometry,
  PerspectiveCamera,
  Vector3,
  Vector2,
  AmbientLight,
  WebGLRenderer,
  Color,
  DirectionalLight,
  DoubleSide,
  sRGBEncoding,
  Scene,
  MeshStandardMaterial,
  Raycaster,
  PMREMGenerator,
  Box3,
  UnsignedByteType,
  MeshPhongMaterial,
  Mesh,
  AnimationMixer,
  Shape,
  ShapePath,
  LineCurve3,
  MirroredRepeatWrapping,
  BufferGeometry,
  BufferAttribute,
  Group,
  MeshBasicMaterial,
  ExtrudeGeometry as ExtrudeGeometryNew,
  PlaneGeometry,
  PlaneBufferGeometry,
  LoopOnce,
  Plane,
} from "three";

import {
  trueAlpha,
  random,
  randomSign,
  preload,
  PromiseAll,
  preloadImage,
  isTouchDevice,
  getTexture,
  newCanvas,
  radialGradientTexture,
} from "../assets/js/utils";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader";
import { SkeletonUtils } from "three/examples/jsm/utils/SkeletonUtils";

import { Text, preloadFont } from "troika-three-text";

//import { ArToolkitProfile } from "@ar-js-org/ar.js";
// import {
//   ArToolkitProfile,
//   ArToolkitSource,
//   ArToolkitContext,
//   ArMarkerControls,
//   ArSmoothedControls,
// } from "../assets/js/ar-threex-nft.js";
// } from "@ar-js-org/ar.js/three.js/build/ar-threex-nft.js";

//import gsap from "gsap";
import { gsap } from "gsap";

//require("@/assets/js/ar-nft.js");
@Component
export default class AR extends Vue {
  isDesktop = true;
  isStarted = false;

  models = {};

  mixers = [];
  debugString = "String";
  loading = true;
  mainTextString =
    "IF YOU LOST YOUR SIGHT, WHAT MOMENT WOULD YOU WANT TO SEE AGAIN?";

  get getDebugString() {
    return this.debugString;
  }

  setDebugString(text) {
    this.debugString = text;
  }

  mounted() {
    //console.log(ArToolkitProfile);
    window.app = this;
    this.startAR();
  }

  beforeDestroy() {
    this.reset();
  }

  reset() {
    window.cancelAnimationFrame(this.raf);
    window.removeEventListener("resize", this.animate.bind(this), false);

    this.controls.dispose();
  }

  onWindowResize() {
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.renderer.setPixelRatio(1);
    this.camera.aspect = this.width / this.height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.width, this.height);
  }

  async startAR() {
    this.initScene();
    this.onWindowResize();
    window.addEventListener("resize", this.onWindowResize.bind(this), false);
    await this.loadResources();
    this.setupObjects();
  }

  async loadResources() {
    const imagesToLoad = {
      //shadow: "images/shadow.jpg",
    };
    const modelsToLoad = {
      // model: "models/anim_7.glb",
      // model: "models/GroundVehicle.glb",
    };
    this.images = {};
    this.models = {};
    this.animations = {};
    const promises = [];
    Object.keys(imagesToLoad).map((key) =>
      promises.push(
        preloadImage(imagesToLoad[key], key).then((data) => {
          this.images[data.key] = data.image;
        })
      )
    );

    promises.push(
      new Promise((resolve, reject) => {
        preloadFont(
          {
            font: "/fonts/FontsFree-Net-aa1woff2-1.ttf",
            characters: this.mainTextString,
          },
          () => {
            resolve();
          }
        );
      })
    );

    // promises.push(
    //   new Promise((resolve, reject) => {
    //     new RGBELoader().setDataType(UnsignedByteType).load(
    //       "./images/env.hdr",
    //       (texture) => {
    //         this.pmremGenerator._renderer.toneMappingExposure = 100;
    //         const envMap =
    //           this.pmremGenerator.fromEquirectangular(texture).texture;
    //         this.hdrEnv = envMap;
    //         resolve({ envMap });
    //       },
    //       undefined,
    //       null
    //     );
    //   })
    // );

    Object.keys(modelsToLoad).map((key) => {
      promises.push(this.loadModel(key, modelsToLoad[key]));
    });
    //

    await Promise.all(promises).then(() => {
      this.loading = false;
      console.log("promiseAll");
      //
    });
  }
  scene: Scene;
  ambient: AmbientLight;
  light: DirectionalLight;
  camera: PerspectiveCamera;
  renderer: WebGLRenderer;
  controls: OrbitControls;
  sceneGroup: Group;
  pmremGenerator: PMREMGenerator;
  mainText: Text;
  initScene() {
    this.scene = new Scene();
    this.ambient = new AmbientLight(0xffffff, 0.5);
    this.scene.add(this.ambient);
    this.light = new DirectionalLight(0xffffff, 0.52);
    this.light.position.set(-1, 20, 15);
    this.scene.add(this.light);

    this.camera = new PerspectiveCamera(56, 1, 0.01, 1000);
    this.camera.position.set(0, 0, 4);
    this.scene.add(this.camera);

    // render
    this.renderer = new WebGLRenderer({
      antialias: true,
      alpha: false,
      powerPreference: "high-performance",
      canvas: this.$refs["3d"],
    });
    this.renderer.setClearColor(0x131e27, 1);
    this.renderer.outputEncoding = sRGBEncoding;
    this.renderer.autoClear = true;

    this.controls = new OrbitControls(this.camera, this.$refs["3d"]);
    this.controls.target.set(0, 0, 0);
    this.controls.dampingFactor = 0.1;
    this.controls.enableDamping = true;

    this.controls.update();
    this.controls.autoRotate = false;
    this.controls.autoRotateSpeed = -2;
    this.sceneGroup = new Group();
    this.scene.add(this.sceneGroup);

    this.pmremGenerator = new PMREMGenerator(this.renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }

  setupObjects() {
    //
    this.initMainText();
    this.raf = window.requestAnimationFrame(this.animate.bind(this));
  }

  initMainText() {
    this.mainText = new Text();
    this.scene.add(this.mainText);

    // Set properties to configure:
    this.mainText.text = this.mainTextString;
    this.mainText.font = "/fonts/FontsFree-Net-aa1woff2-1.ttf";
    this.mainText.fontSize = 0.2;
    this.mainText.position.z = 0;
    this.mainText.color = 0xffffff;
    this.mainText.maxWidth = 2.8;
    this.mainText.textAlign = "center";
    this.mainText.anchorX = "center";
    this.mainText.anchorY = "middle";

    this.mainText.fillOpacity = 0.0;

    this.mainText.outlineBlur = 0.06;
    this.mainText.outlineOpacity = 0;
    //this.mainText.outlineWidth = 0.001;

    this.mainText.outlineColor = 0xffffff;

    gsap.to(this.mainText, {
      duration: 2,
      delay: 0.3,
      outlineBlur: 0.0001,
      outlineOpacity: 1,
      ease: "power3.in",
      onUpdate: () => {
        //
      },
      onComplete: () => {
        this.mainText.fillOpacity = 1;
        this.mainText.outlineBlur = 0;
      },
    });

    // Update the rendering:
    this.mainText.sync();
  }

  canvasClick() {
    //
  }

  getCorrectPath(url) {
    let correctUrl = url;
    correctUrl =
      correctUrl.slice(-1) === "/" ? correctUrl.slice(0, -1) : correctUrl;
    correctUrl = correctUrl.replace(/\/[^/]+?\.[^/]+?$/, "").slice(1);
    return correctUrl;
  }

  loadModel(key, url) {
    return new Promise((resolve, reject) => {
      new GLTFLoader().load(
        // resource URL
        url,
        // called when the resource is loaded
        (model) => {
          const scene = model.scene;
          //scene.children[0].name = key;
          this.models[key] = scene;
          // this.animations[key] = model.animations || [];

          this.clips = model.animations || [];

          // this.clips.forEach((clip, clipIndex) => {
          //   // Autoplay the first clip.
          //   let action;
          //   if (clipIndex === 0) {
          //     action = this.mixer.clipAction(clip);
          //     action.play();
          //   }
          // });
          resolve({ scene });
        },
        // called when loading is in progresses
        (xhr) => {
          //  console.log(`${xhr.loaded / xhr.total * 100}% loaded`);
        },
        // called when loading has errors
        (error) => {
          // console.log('An error happened');
        }
      );
    });
  }

  setClips(clips, model) {
    if (this.mixer) {
      this.mixer.stopAllAction();
      this.mixer.uncacheRoot(this.mixer.getRoot());
      this.mixer = null;
    }
    this.clips = clips;
    if (!clips.length) return;

    this.mixer = new AnimationMixer(model);
  }

  animate(nowMsec) {
    this.lastTimeMsec = this.lastTimeMsec || nowMsec - 1000 / 60;
    const deltaMsec = Math.min(200, nowMsec - this.lastTimeMsec);
    this.lastTimeMsec = nowMsec;

    // this.mixers.forEach((mixer) => {
    //   mixer.update(deltaMsec / 1000);
    // });

    //this.mixer && this.mixer.update(deltaMsec / 1000);

    this.controls.update();
    this.renderer.render(this.scene, this.camera);

    this.raf = window.requestAnimationFrame(this.animate.bind(this));
  }

  static sortLayers(a, b) {
    if (a.cameraDist < b.cameraDist) {
      return 1;
    }
    if (a.cameraDist > b.cameraDist) {
      return -1;
    }
    return 0;
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style lang="scss" scoped>
@import "@/assets/scss/app.scss";
.subcont {
  font-size: 16px;
  bottom: 70px;
  width: 100%;
  box-sizing: border-box;
  padding: 20px;
  position: absolute;
  z-index: 6;
  line-height: 1.5em;
  @include font($font-alright-normal);
  @include desktop-up-layout {
    font-size: 32px;
  }
}
.subtitles {
  display: inline;
  background: #253746;
  color: white;
  padding: 0.28em;
  padding-left: 0;
  padding-right: 0;
  box-shadow: 8px 0 0 #253746, -8px 0 0 #253746;
}
.ar {
  overscroll-behavior: none;
  &__canvas {
    position: fixed;
    left: 0;
    top: 0;
  }
}
.debug {
  font-size: 16px;
  font-weight: 400;
  position: fixed;
  bottom: 0;
  left: 0;
  text-align: left;
  background: rgba(0, 0, 0, 0.3);
  color: #fff;
  padding: 10px;
  z-index: 100;
}
.loader {
  background: rgba(0, 0, 0, 0.4);
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 99;
  color: #fff;
  font-size: 20px;
  font-weight: 400;
}
</style>
